// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String? // Optional for OAuth users
  firstName String?
  lastName  String?
  phone     String?
  role      UserRole @default(CUSTOMER)
  isActive  Boolean  @default(true)
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Global Platform Features
  country                      String?
  whatsappNumber               String?
  // IMPORTANT: Keep as String to match existing production migrations which created this column as TEXT.
  // Validation still happens at the API boundary (DTO). Using a Prisma enum here requires a Postgres enum
  // type to exist in the DB, which is not currently present in production.
  preferredCommunicationMethod String?
  currencyPreference           String    @default("GBP")
  ipAddress                    String?
  gdprConsent                  Boolean   @default(false)
  gdprConsentDate              DateTime?
  dataProcessingConsent        Json?
  countryDetectedAt            DateTime?

  // RBAC: optional permission-role (custom role) for fine-grained permissions
  permissionRoleId String?
  permissionRole   PermissionRole? @relation(fields: [permissionRoleId], references: [id])

  // Relations
  addresses             Address[]
  orders                Order[]
  cart                  Cart?                  @relation(fields: [cartId], references: [id])
  sellerProfile         Seller?
  customerProfile       Customer?
  loyaltyPoints         Int                    @default(0)
  refreshTokens         RefreshToken[]
  themePreference       String?
  reviews               ProductReview[]
  wishlistItems         WishlistItem[]
  returnRequests        ReturnRequest[]
  invitedSellers        SellerInvitation[]     @relation("InvitedBy")
  activityLogs          ActivityLog[]
  transactions          Transaction[]          @relation("CustomerTransactions")
  supportTickets        SupportTicket[]        @relation("UserTickets")
  assignedTickets       SupportTicket[]        @relation("AssignedTickets")
  ticketMessages        TicketMessage[]        @relation("TicketMessages")
  whatsappConversations WhatsAppConversation[]
  cartId                String?

  // Phase 6: Fandom Experience Relations
  characterAvatarId  String?
  characterAvatar    Character?   @relation("CharacterAvatar", fields: [characterAvatarId], references: [id])
  favoriteFandoms    String[]     @default([])
  gamificationPoints Int          @default(0)
  level              Int          @default(1)
  aiPreferences      Json?
  aiChats            AIChat[]
  userBadges         UserBadge[]
  userQuests         UserQuest[]
  collections        Collection[]
  sharedItems        SharedItem[]

  // GDPR Relations
  gdprConsentLogs GDPRConsentLog[]

  // OAuth Relations
  oAuthAccounts OAuthAccount[]

  // Gift Card Relations
  giftCards GiftCard[]

  // Customer Group Relations
  customerGroupId String?
  customerGroup   CustomerGroup? @relation(fields: [customerGroupId], references: [id], onDelete: SetNull)

  // Coupon Usage Relations
  couponUsages CouponUsage[]

  // Multi-Tenancy Relations
  tenantMemberships TenantUser[]
  defaultTenantId   String?
  defaultTenant     Tenant?      @relation("DefaultTenant", fields: [defaultTenantId], references: [id], onDelete: SetNull)

  // Marketing dates (for personalized campaigns)
  birthday    DateTime? // Store month/day for birthday discounts
  anniversary DateTime? // Optional for gift suggestions

  // Team member specific fields
  department    String?
  employeeId    String?
  managerId     String?
  manager       User?   @relation("ManagerReports", fields: [managerId], references: [id], onDelete: SetNull)
  directReports User[]  @relation("ManagerReports")

  // Influencer Relations
  influencerProfile     Influencer?
  influencerInvitations InfluencerInvitation[] @relation("InfluencerInvitedBy")

  // Account Lockout
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?

  // Newsletter
  newsletterSubscriptions NewsletterSubscription[]

  // Soft delete
  deletedAt DateTime?

  @@index([deletedAt])
  @@map("users")
}

// Custom role definitions stored in DB (role name + permission ids)
model PermissionRole {
  id          String   @id @default(uuid())
  name        String   @unique
  permissions Json // array of permission ids (e.g. ["users.view","orders.view"])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users User[]

  @@map("permission_roles")
}

// Multi-Tenancy Models
// Tenant model - Top-level organization
model Tenant {
  id        String   @id @default(uuid())
  name      String
  domain    String?  @unique // Optional custom domain
  subdomain String?  @unique // Optional subdomain identifier
  isActive  Boolean  @default(true)
  config    Json? // Tenant-level configuration
  metadata  Json? // Additional tenant metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  stores       Store[]
  tenantUsers  TenantUser[]
  configs      Config[]     @relation("TenantConfigs")
  defaultUsers User[]       @relation("DefaultTenant")

  @@index([domain])
  @@index([subdomain])
  @@map("tenants")
}

// Many-to-many: Users can belong to multiple tenants
model TenantUser {
  id        String   @id @default(uuid())
  tenantId  String
  userId    String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String // Role within this tenant (ADMIN, MANAGER, STAFF, CUSTOMER, SELLER, etc.)
  isActive  Boolean  @default(true)
  joinedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, userId])
  @@index([tenantId])
  @@index([userId])
  @@map("tenant_users")
}

// Store model - Will be fully implemented in Phase 2
// Placeholder to resolve Tenant relations
model Store {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name      String   @default("Store") // Placeholder, will be expanded in Phase 2
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  configs Config[] @relation("StoreConfigs")

  @@index([tenantId])
  @@map("stores")
}

// Config model - Will be fully implemented in Phase 4
// Placeholder to resolve Tenant relations
model Config {
  id        String   @id @default(uuid())
  level     String // PLATFORM, TENANT, STORE, CHANNEL
  levelId   String
  key       String
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenantId String?
  tenant   Tenant? @relation("TenantConfigs", fields: [tenantId], references: [id], onDelete: Cascade)
  storeId  String?
  store    Store?  @relation("StoreConfigs", fields: [storeId], references: [id], onDelete: Cascade)

  @@index([level, levelId])
  @@index([tenantId])
  @@index([storeId])
  @@map("configs")
}

enum UserRole {
  CUSTOMER
  WHOLESALER
  B2C_SELLER
  // DEPRECATED: SELLER role is legacy and should be migrated to B2C_SELLER.
  // Run `pnpm db:migrate-seller-role` to migrate existing users.
  // After migration, update code to use B2C_SELLER only, then remove this value.
  SELLER
  ADMIN
  INFLUENCER
  PROCUREMENT
  FULFILLMENT
  CATALOG
  MARKETING
  FINANCE
  CMS_EDITOR
}

// Note: Communication method values are validated in DTOs (see `src/auth/dto/register.dto.ts`).

// Customer profile
model Customer {
  id                 String  @id @default(uuid())
  userId             String  @unique
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  loyaltyPoints      Int     @default(0)
  themePreference    String?
  country            String?
  currencyPreference String  @default("GBP")

  // B2B/Wholesaler fields (null for regular customers)
  companyName       String?
  businessRegNumber String?
  vatNumber         String?
  businessType      String? // RETAIL, DISTRIBUTOR, RESELLER
  creditTerms       String? // NET_30, NET_60, PREPAID
  billingAddressId  String?

  @@map("customers")
}

// Seller model
model Seller {
  id                     String          @id @default(uuid())
  userId                 String          @unique
  user                   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  storeName              String
  slug                   String          @unique
  description            String?         @db.Text
  themeId                String?
  logo                   String?
  country                String
  city                   String?
  region                 String?
  timezone               String          @default("UTC")
  verified               Boolean         @default(false)
  rating                 Float?
  totalSales             Int             @default(0)
  sellerType             SellerType      @default(B2C_SELLER)
  customDomain           String?
  subDomain              String?
  domainPackagePurchased Boolean         @default(false)
  logisticsOption        LogisticsOption @default(HOS_LOGISTICS)
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt

  // Business compliance fields
  legalBusinessName String?
  companyName       String?
  vatNumber         String?

  // Bank details (encrypted)
  bankName         String?
  accountHolder    String?
  accountNumberEnc String? // Encrypted
  sortCodeEnc      String? // Encrypted

  // Warehouse/operations address
  warehouseAddressId String?

  // Operations contact
  opsContactName  String?
  opsContactEmail String?
  opsContactPhone String?

  // Relations
  products              Product[]
  orders                Order[]
  themeSettings         SellerThemeSettings?
  submissions           ProductSubmission[]
  settlements           Settlement[]
  activityLogs          ActivityLog[]
  discrepancies         Discrepancy[]
  supportTickets        SupportTicket[]
  whatsappConversations WhatsAppConversation[]
  transactions          Transaction[]
  promotions            Promotion[]
  shippingMethods       ShippingMethod[]
  webhooks              Webhook[]
  returnPolicies        ReturnPolicy[]

  // Soft delete
  deletedAt DateTime?

  @@index([deletedAt])
  @@map("sellers")
}

// Theme model
model Theme {
  id            String    @id @default(uuid())
  name          String
  type          ThemeType
  sellerId      String?
  config        Json // Theme configuration object
  isActive      Boolean   @default(true)
  version       Int       @default(1)
  // Theme upload fields
  versionString String? // Semantic version string (e.g., "1.0.0")
  description   String?   @db.Text
  previewImages String[]
  assets        Json? // CSS, JS, images, fonts
  metadata      Json? // author, tags, compatibility
  storageUrl    String? // S3/MinIO URL
  uploadedBy    String?
  uploadedAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  sellerThemeSettings SellerThemeSettings[]

  @@map("themes")
}

enum ThemeType {
  HOS
  SELLER
  CUSTOMER
}

// Seller theme settings
model SellerThemeSettings {
  id               String   @id @default(uuid())
  sellerId         String   @unique
  seller           Seller   @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  themeId          String
  theme            Theme    @relation(fields: [themeId], references: [id])
  customLogoUrl    String?
  customFaviconUrl String?
  customColors     Json?
  updatedAt        DateTime @updatedAt

  @@map("seller_theme_settings")
}

// Product model
model Product {
  id              String        @id @default(uuid())
  sellerId        String?
  seller          Seller?       @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  isPlatformOwned Boolean       @default(false)
  name            String
  description     String        @db.Text
  shortDescription String?     @db.Text
  slug            String
  sku             String?
  barcode         String?
  ean             String?
  price           Decimal       @db.Decimal(10, 2)
  tradePrice      Decimal?      @db.Decimal(10, 2)
  rrp             Decimal?      @db.Decimal(10, 2)
  currency        String        @default("GBP")
  taxRate         Decimal       @default(0) @db.Decimal(5, 4)
  stock           Int           @default(0)
  fandom          String?
  category        String? // Keep for backward compatibility during migration
  tags            String[] // Keep for backward compatibility during migration
  categoryId      String? // New: relation to Category
  status          ProductStatus @default(DRAFT)
  productType     ProductType   @default(SIMPLE) // SIMPLE, VARIANT, BUNDLED
  parentProductId String? // For variant products, reference to parent
  parentProduct   Product?      @relation("ProductVariants", fields: [parentProductId], references: [id], onDelete: Cascade)
  variantProducts Product[]     @relation("ProductVariants") // Child variants
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  images             ProductImage[]
  variations         ProductVariation[]
  cartItems          CartItem[]
  orderItems         OrderItem[]
  reviews            ProductReview[]
  wishlistItems      WishlistItem[]
  discrepancies      Discrepancy[]
  averageRating      Float?
  reviewCount        Int                     @default(0)
  submission         ProductSubmission?
  pricing            ProductPricing?
  duplicateProducts  DuplicateProduct[]
  categoryRelation   Category?               @relation(fields: [categoryId], references: [id])
  tagsRelation       ProductTag[]
  attributes         ProductAttribute[]
  inventoryLocations InventoryLocation[]
  stockTransfers     StockTransfer[]
  stockMovements     StockMovement[]
  taxClassId         String?
  taxClass           TaxClass?               @relation(fields: [taxClassId], references: [id], onDelete: SetNull)
  returnPolicies     ReturnPolicy[]
  bundleItems        ProductBundleItem[]     @relation("ProductBundles") // For bundled products
  bundledIn          ProductBundleItem[]     @relation("ProductBundledIn") // Products that are part of bundles
  volumePricing      VolumePricing[] // Quantity-based pricing tiers
  influencerLinks    InfluencerProductLink[]

  // Soft delete
  deletedAt DateTime?

  @@unique([sellerId, slug])
  @@index([productType])
  @@index([parentProductId])
  @@index([status])
  @@index([sellerId, status])
  @@index([deletedAt])
  @@index([sku])
  @@index([barcode])
  @@index([ean])
  @@map("products")
}

enum ProductStatus {
  DRAFT
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum ProductType {
  SIMPLE // Single product without variations
  VARIANT // Product with variations (size, color, etc.)
  BUNDLED // Bundle of multiple products
}

// Product images
model ProductImage {
  id        String    @id @default(uuid())
  productId String
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  url       String
  alt       String?
  order     Int       @default(0)
  type      ImageType @default(IMAGE)

  @@map("product_images")
}

enum ImageType {
  IMAGE
  VIDEO
  IMAGE_360
}

// Product variations (for VARIANT type products)
model ProductVariation {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  name      String // e.g., "Size", "Color"
  options   Json // Array of variation options

  @@map("product_variations")
}

// Product Bundle Items (for BUNDLED type products)
model ProductBundleItem {
  id              String   @id @default(uuid())
  bundleProductId String // Parent bundle product
  bundleProduct   Product  @relation("ProductBundles", fields: [bundleProductId], references: [id], onDelete: Cascade)
  productId       String // Product in bundle
  product         Product  @relation("ProductBundledIn", fields: [productId], references: [id], onDelete: Cascade)
  quantity        Int      @default(1) // Quantity of this product in bundle
  priceOverride   Decimal? @db.Decimal(10, 2) // Optional price override for this item
  isRequired      Boolean  @default(true) // Whether this item is required in bundle
  order           Int      @default(0) // Display order

  @@unique([bundleProductId, productId])
  @@index([bundleProductId])
  @@index([productId])
  @@map("product_bundle_items")
}

// Volume Pricing (quantity-based discounts)
model VolumePricing {
  id            String   @id @default(uuid())
  productId     String
  product       Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  minQuantity   Int // Minimum quantity for this tier
  maxQuantity   Int? // Maximum quantity for this tier (null = no max)
  discountType  String // 'PERCENTAGE' or 'FIXED'
  discountValue Decimal  @db.Decimal(10, 2) // Discount amount or percentage
  price         Decimal? @db.Decimal(10, 2) // Fixed price at this tier (overrides discount)
  priority      Int      @default(0) // Higher priority = applied first
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([productId])
  @@index([minQuantity])
  @@index([isActive])
  @@map("volume_pricing")
}

// Cart model
model Cart {
  id         String     @id @default(uuid())
  userId     String?    @unique
  items      CartItem[]
  total      Decimal    @default(0) @db.Decimal(10, 2)
  subtotal   Decimal    @default(0) @db.Decimal(10, 2)
  tax        Decimal    @default(0) @db.Decimal(10, 2)
  discount   Decimal    @default(0) @db.Decimal(10, 2) // Total discount amount
  shipping   Decimal    @default(0) @db.Decimal(10, 2) // Shipping cost
  currency   String     @default("GBP")
  couponCode String? // Applied coupon code
  coupon     Coupon?    @relation(fields: [couponCode], references: [code], onDelete: SetNull)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  users      User[]

  @@map("carts")
}

// Cart items
model CartItem {
  id               String  @id @default(uuid())
  cartId           String
  cart             Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  productId        String
  product          Product @relation(fields: [productId], references: [id])
  quantity         Int     @default(1)
  variationOptions Json? // Store selected variation options
  price            Decimal @db.Decimal(10, 2)

  @@map("cart_items")
}

// Address model
model Address {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  label      String?
  firstName  String
  lastName   String
  street     String
  city       String
  state      String?
  postalCode String
  country    String
  phone      String?
  latitude   Float? // For geo-based routing
  longitude  Float? // For geo-based routing
  isDefault  Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations for orders
  shippingOrders Order[] @relation("ShippingAddress")
  billingOrders  Order[] @relation("BillingAddress")

  @@index([userId])
  @@index([country])
  @@index([city])
  @@map("addresses")
}

// Order model
model Order {
  id                String        @id @default(uuid())
  userId            String
  user              User          @relation(fields: [userId], references: [id])
  sellerId          String?
  seller            Seller?       @relation(fields: [sellerId], references: [id])
  orderNumber       String        @unique
  items             OrderItem[]
  subtotal          Decimal       @db.Decimal(10, 2)
  tax               Decimal       @db.Decimal(10, 2)
  total             Decimal       @db.Decimal(10, 2)
  currency          String        @default("GBP")
  status            OrderStatus   @default(PENDING)
  shippingAddressId String
  shippingAddress   Address       @relation("ShippingAddress", fields: [shippingAddressId], references: [id])
  billingAddressId  String
  billingAddress    Address       @relation("BillingAddress", fields: [billingAddressId], references: [id])
  paymentMethod     String?
  paymentStatus     PaymentStatus @default(PENDING)
  trackingCode      String?

  // Fulfillment routing
  fulfillingWarehouseId String?
  fulfillingWarehouse   Warehouse?         @relation(fields: [fulfillingWarehouseId], references: [id])
  fulfillmentCenterId   String?
  fulfillmentCenter     FulfillmentCenter? @relation(fields: [fulfillmentCenterId], references: [id])
  estimatedDistance     Float? // Distance in km from warehouse to customer
  routingMethod         String? // NEAREST, ZONE_BASED, MANUAL

  notes                OrderNote[]
  payments             Payment[]
  returnRequests       ReturnRequest[]
  orderSettlements     OrderSettlement[]
  transactions         Transaction[]
  discrepancies        Discrepancy[]
  supportTickets       SupportTicket[]       @relation("OrderTickets")
  giftCardTransactions GiftCardTransaction[]
  couponUsages         CouponUsage[]
  stockReservations    StockReservation[]
  referral             Referral?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  // Soft delete
  deletedAt DateTime?

  @@index([fulfillingWarehouseId])
  @@index([fulfillmentCenterId])
  @@index([status])
  @@index([userId])
  @@index([sellerId])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("orders")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  FULFILLED
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

// Order items
model OrderItem {
  id               String       @id @default(uuid())
  orderId          String
  order            Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId        String
  product          Product      @relation(fields: [productId], references: [id])
  quantity         Int
  price            Decimal      @db.Decimal(10, 2)
  variationOptions Json?
  returnItems      ReturnItem[] // Item-level returns

  @@map("order_items")
}

// Order notes
model OrderNote {
  id        String   @id @default(uuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  content   String   @db.Text
  internal  Boolean  @default(false) // If true, only seller/admin can see
  createdBy String
  createdAt DateTime @default(now())

  @@map("order_notes")
}

// Product Review model
model ProductReview {
  id        String       @id @default(uuid())
  productId String
  product   Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  rating    Int // 1-5 stars
  title     String?
  comment   String?      @db.Text
  verified  Boolean      @default(false) // If user purchased the product
  helpful   Int          @default(0) // Helpful votes count
  status    ReviewStatus @default(PENDING)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([productId, userId]) // One review per product per user
  @@map("product_reviews")
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

// Wishlist model
model WishlistItem {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, productId]) // One wishlist entry per product per user
  @@map("wishlist_items")
}

// Return Policy model
model ReturnPolicy {
  id                 String          @id @default(uuid())
  name               String
  description        String?         @db.Text
  sellerId           String? // If null, platform-wide policy
  seller             Seller?         @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  productId          String? // If null, applies to all products
  product            Product?        @relation(fields: [productId], references: [id], onDelete: Cascade)
  categoryId         String? // If null, applies to all categories
  isReturnable       Boolean         @default(true)
  returnWindowDays   Int             @default(30) // Days from delivery to allow returns
  requiresApproval   Boolean         @default(false)
  requiresInspection Boolean         @default(false)
  refundMethod       String? // 'ORIGINAL_PAYMENT', 'STORE_CREDIT', 'EXCHANGE'
  restockingFee      Decimal?        @db.Decimal(10, 2) // Percentage or fixed amount
  priority           Int             @default(0) // Higher priority = applied first
  isActive           Boolean         @default(true)
  returnRequests     ReturnRequest[]
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  @@index([sellerId])
  @@index([productId])
  @@index([categoryId])
  @@index([isActive])
  @@map("return_policies")
}

// Return Request model
model ReturnRequest {
  id             String        @id @default(uuid())
  orderId        String
  order          Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  userId         String
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  returnPolicyId String?
  returnPolicy   ReturnPolicy? @relation(fields: [returnPolicyId], references: [id], onDelete: SetNull)
  reason         String        @db.Text
  status         ReturnStatus  @default(PENDING)
  refundAmount   Decimal?      @db.Decimal(10, 2)
  refundMethod   String?
  notes          String?       @db.Text
  processedAt    DateTime?
  items          ReturnItem[] // Item-level returns
  transactions   Transaction[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@map("return_requests")
}

// Return Item model (for item-level returns)
model ReturnItem {
  id              String           @id @default(uuid())
  returnRequestId String
  returnRequest   ReturnRequest    @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  orderItemId     String
  orderItem       OrderItem        @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  quantity        Int // Quantity to return (can be partial)
  reason          String?          @db.Text
  status          ReturnItemStatus @default(PENDING)
  refundAmount    Decimal?         @db.Decimal(10, 2) // Refund amount for this item
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([returnRequestId])
  @@index([orderItemId])
  @@map("return_items")
}

enum ReturnItemStatus {
  PENDING
  APPROVED
  REJECTED
  RECEIVED
  INSPECTED
  REFUNDED
  CANCELLED
}

enum ReturnStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  COMPLETED
  CANCELLED
}

// Payment model (for Stripe integration)
model Payment {
  id              String        @id @default(uuid())
  orderId         String
  order           Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  stripePaymentId String?       @unique
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("GBP")
  status          PaymentStatus @default(PENDING)
  paymentMethod   String?
  refundAmount    Decimal?      @db.Decimal(10, 2)
  metadata        Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@map("payments")
}

// Refresh Token model for secure token rotation and revocation
model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String // Hashed refresh token (bcrypt)
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// OAuth Account model for social login (Google, Facebook, Apple)
model OAuthAccount {
  id           String    @id @default(uuid())
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider     String // 'google', 'facebook', 'apple'
  providerId   String // Unique ID from OAuth provider
  accessToken  String? // Encrypted access token
  refreshToken String? // Encrypted refresh token
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
  @@index([provider])
  @@map("oauth_accounts")
}

// Notification model (for email notifications)
model Notification {
  id        String             @id @default(uuid())
  userId    String
  type      NotificationType
  subject   String?
  content   String             @db.Text
  email     String?
  status    NotificationStatus @default(PENDING)
  sentAt    DateTime?
  readAt    DateTime?
  metadata  Json?
  createdAt DateTime           @default(now())

  @@index([userId, readAt])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  ORDER_CONFIRMATION
  ORDER_SHIPPED
  ORDER_DELIVERED
  ORDER_CANCELLED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  RETURN_REQUESTED
  RETURN_APPROVED
  REVIEW_REMINDER
  WISHLIST_SALE
  // Submission workflow notifications
  SUBMISSION_APPROVED
  SUBMISSION_REJECTED
  SUBMISSION_RESUBMITTED
  CATALOG_COMPLETED
  MARKETING_COMPLETED
  FINANCE_APPROVED
  FINANCE_REJECTED
  PRODUCT_PUBLISHED
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}

// New enums for workflow and seller types
enum SellerType {
  WHOLESALER
  B2C_SELLER
}

enum ProductSubmissionStatus {
  SUBMITTED
  UNDER_REVIEW
  PROCUREMENT_APPROVED
  PROCUREMENT_REJECTED
  SHIPPED_TO_FC
  FC_ACCEPTED
  FC_REJECTED
  CATALOG_PENDING
  CATALOG_COMPLETED
  MARKETING_PENDING
  MARKETING_COMPLETED
  FINANCE_PENDING
  FINANCE_APPROVED
  PUBLISHED
  REJECTED
}

enum LogisticsOption {
  HOS_LOGISTICS
  SELLER_OWN
  HOS_PARTNER
}

enum ShipmentStatus {
  PENDING
  IN_TRANSIT
  RECEIVED
  VERIFIED
  REJECTED
}

enum MaterialType {
  BANNER
  CREATIVE
  PRODUCT_IMAGE
  CAMPAIGN_ASSET
}

enum VisibilityLevel {
  STANDARD
  FEATURED
  PREMIUM
  HIDDEN
}

// Product Submission model
model ProductSubmission {
  id                    String                  @id @default(uuid())
  sellerId              String
  seller                Seller                  @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  productData           Json // Raw product data from seller
  status                ProductSubmissionStatus @default(SUBMITTED)
  procurementNotes      String?                 @db.Text
  catalogNotes          String?                 @db.Text
  marketingNotes        String?                 @db.Text
  financeNotes          String?                 @db.Text
  selectedQuantity      Int? // Quantity selected by procurement
  procurementApprovedAt DateTime?
  fcAcceptedAt          DateTime?
  catalogCompletedAt    DateTime?
  marketingCompletedAt  DateTime?
  financeApprovedAt     DateTime?
  publishedAt           DateTime?
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  crossSellerGroupId    String?                 // Set by duplicate grouping (cron or on-demand) for reporting
  pricingData           Json?                   // Structured pricing data set by finance (basePrice, hosMargin, finalPrice, visibilityLevel)
  version               Int                     @default(1) // Optimistic concurrency control

  // Relations
  product            Product?            @relation(fields: [productId], references: [id])
  productId          String?             @unique
  shipment           Shipment?
  catalogEntry       CatalogEntry?
  marketingMaterials MarketingMaterial[]
  duplicateProducts  DuplicateProduct[]

  // Soft delete
  deletedAt DateTime?

  @@index([crossSellerGroupId])
  @@index([status])
  @@index([sellerId, status])
  @@index([status, createdAt])
  @@index([deletedAt])
  @@map("product_submissions")
}

// Fulfillment Center model
model FulfillmentCenter {
  id           String   @id @default(uuid())
  name         String
  address      String
  city         String
  country      String
  postalCode   String?
  latitude     Float?
  longitude    Float?
  contactEmail String?
  contactPhone String?
  capacity     Int? // Storage capacity in cubic meters or units
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  shipments Shipment[]
  orders    Order[]

  @@index([isActive])
  @@index([city])
  @@index([country])
  @@map("fulfillment_centers")
}

// Shipment model
model Shipment {
  id                  String            @id @default(uuid())
  submissionId        String            @unique
  submission          ProductSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  fulfillmentCenterId String
  fulfillmentCenter   FulfillmentCenter @relation(fields: [fulfillmentCenterId], references: [id])
  logisticsPartnerId  String?
  logisticsPartner    LogisticsPartner? @relation(fields: [logisticsPartnerId], references: [id])
  trackingNumber      String?
  shippedAt           DateTime?
  receivedAt          DateTime?
  status              ShipmentStatus    @default(PENDING)
  verificationNotes   String?           @db.Text
  verifiedBy          String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@map("shipments")
}

// Catalog Entry model
model CatalogEntry {
  id           String            @id @default(uuid())
  submissionId String            @unique
  submission   ProductSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  title        String
  description  String            @db.Text
  keywords     String[]
  specs        Json?
  images       String[]
  completedBy  String?
  completedAt  DateTime?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@map("catalog_entries")
}

// Marketing Material model
model MarketingMaterial {
  id           String            @id @default(uuid())
  submissionId String
  submission   ProductSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  type         MaterialType
  url          String
  createdBy    String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@map("marketing_materials")
}

// Product Pricing model
model ProductPricing {
  id              String          @id @default(uuid())
  productId       String          @unique
  product         Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  basePrice       Decimal         @db.Decimal(10, 2)
  hosMargin       Decimal         @db.Decimal(5, 4) // Percentage
  finalPrice      Decimal         @db.Decimal(10, 2)
  visibilityLevel VisibilityLevel @default(STANDARD)
  approvedBy      String?
  approvedAt      DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("product_pricing")
}

// Duplicate Product model
model DuplicateProduct {
  id                String            @id @default(uuid())
  submissionId      String
  submission        ProductSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  existingProductId String
  existingProduct   Product           @relation(fields: [existingProductId], references: [id], onDelete: Cascade)
  similarityScore   Float
  detectedAt        DateTime          @default(now())

  @@unique([submissionId, existingProductId])
  @@map("duplicate_products")
}

// Logistics Partner model
model LogisticsPartner {
  id             String   @id @default(uuid())
  name           String
  description    String?  @db.Text
  website        String?
  country        String?
  isActive       Boolean  @default(true)
  contactInfo    Json? // Contact information
  trackingApiUrl String?
  apiKey         String? // Encrypted API key
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  shipments Shipment[]

  @@map("logistics_partners")
}

// Settlement model
model Settlement {
  id            String           @id @default(uuid())
  sellerId      String
  seller        Seller           @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  periodStart   DateTime
  periodEnd     DateTime
  totalSales    Decimal          @db.Decimal(10, 2)
  totalOrders   Int
  platformFee   Decimal          @db.Decimal(10, 2)
  netAmount     Decimal          @db.Decimal(10, 2)
  currency      String           @default("GBP")
  status        SettlementStatus @default(PENDING)
  paymentMethod String?
  paidAt        DateTime?
  notes         String?          @db.Text
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  orderSettlements OrderSettlement[]
  transactions     Transaction[]
  discrepancies    Discrepancy[]

  @@map("settlements")
}

enum SettlementStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  CANCELLED
}

// Order Settlement (many-to-many relationship between orders and settlements)
model OrderSettlement {
  id           String     @id @default(uuid())
  settlementId String
  settlement   Settlement @relation(fields: [settlementId], references: [id], onDelete: Cascade)
  orderId      String
  order        Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  amount       Decimal    @db.Decimal(10, 2)
  platformFee  Decimal    @db.Decimal(10, 2)
  createdAt    DateTime   @default(now())

  @@unique([settlementId, orderId])
  @@map("order_settlements")
}

// Fandom model (Phase 6)
model Fandom {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?  @db.Text
  image       String?
  banner      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Relations
  characters Character[]
  quests     Quest[]

  @@map("fandoms")
}

// Character model (Phase 6)
model Character {
  id           String   @id @default(uuid())
  fandomId     String
  fandom       Fandom   @relation(fields: [fandomId], references: [id], onDelete: Cascade)
  name         String
  description  String?  @db.Text
  personality  String?  @db.Text // JSON personality traits
  systemPrompt String?  @db.Text // AI system prompt
  avatar       String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())

  // Relations
  aiChats AIChat[]
  users   User[]   @relation("CharacterAvatar")

  @@map("characters")
}

// AI Chat model (Phase 6)
model AIChat {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  messages    Json      @default("[]")
  context     Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("ai_chats")
}

// Badge model (Phase 6)
model Badge {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text
  icon        String?
  category    String
  rarity      String  @default("COMMON")
  points      Int     @default(0)
  isActive    Boolean @default(true)

  // Relations
  userBadges UserBadge[]
  quests     Quest[]

  @@map("badges")
}

// User Badge model (Phase 6)
model UserBadge {
  id       String   @id @default(uuid())
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId  String
  badge    Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@map("user_badges")
}

// Quest model (Phase 6)
model Quest {
  id           String    @id @default(uuid())
  name         String
  description  String?   @db.Text
  type         String
  fandomId     String?
  fandom       Fandom?   @relation(fields: [fandomId], references: [id])
  points       Int       @default(0)
  badgeId      String?
  badge        Badge?    @relation(fields: [badgeId], references: [id])
  requirements Json?
  isActive     Boolean   @default(true)
  startsAt     DateTime?
  endsAt       DateTime?

  // Relations
  userQuests UserQuest[]

  @@map("quests")
}

// User Quest model (Phase 6)
model UserQuest {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  questId     String
  quest       Quest     @relation(fields: [questId], references: [id], onDelete: Cascade)
  progress    Json?
  status      String    @default("IN_PROGRESS")
  completedAt DateTime?

  @@unique([userId, questId])
  @@map("user_quests")
}

// Collection model (Phase 6)
model Collection {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?  @db.Text
  items       Json     @default("[]")
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@map("collections")
}

// Shared Item model (Phase 6)
model SharedItem {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String
  itemId    String
  content   Json
  platform  String?
  views     Int      @default(0)
  createdAt DateTime @default(now())

  @@map("shared_items")
}

// Currency Exchange Rate model
model CurrencyExchangeRate {
  id             String   @id @default(uuid())
  baseCurrency   String   @default("GBP")
  targetCurrency String
  rate           Decimal  @db.Decimal(10, 6)
  cachedAt       DateTime @default(now())
  expiresAt      DateTime

  @@unique([baseCurrency, targetCurrency])
  @@map("currency_exchange_rates")
}

// Gift Card model
model GiftCard {
  id            String                @id @default(uuid())
  code          String                @unique
  userId        String? // Owner (null if not yet assigned)
  user          User?                 @relation(fields: [userId], references: [id], onDelete: SetNull)
  type          String                @default("digital") // 'digital' or 'physical'
  amount        Decimal               @db.Decimal(10, 2)
  balance       Decimal               @db.Decimal(10, 2) // Remaining balance
  currency      String                @default("GBP")
  status        String                @default("ACTIVE") // 'ACTIVE', 'REDEEMED', 'EXPIRED', 'CANCELLED'
  issuedToEmail String?
  issuedToName  String?
  expiresAt     DateTime?
  message       String?               @db.Text
  purchasedAt   DateTime              @default(now())
  redeemedAt    DateTime?
  transactions  GiftCardTransaction[]
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  @@index([code])
  @@index([userId])
  @@index([status])
  @@map("gift_cards")
}

// Gift Card Transaction model (tracks redemptions and refunds)
model GiftCardTransaction {
  id           String   @id @default(uuid())
  giftCardId   String
  giftCard     GiftCard @relation(fields: [giftCardId], references: [id], onDelete: Cascade)
  orderId      String?
  order        Order?   @relation(fields: [orderId], references: [id], onDelete: SetNull)
  type         String // 'REDEMPTION', 'REFUND', 'PURCHASE'
  amount       Decimal  @db.Decimal(10, 2)
  balanceAfter Decimal  @db.Decimal(10, 2) // Balance after this transaction
  notes        String?  @db.Text
  createdAt    DateTime @default(now())

  @@index([giftCardId])
  @@index([orderId])
  @@map("gift_card_transactions")
}

// GDPR Consent Log model
model GDPRConsentLog {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  consentType String // "MARKETING", "ANALYTICS", "ESSENTIAL", etc.
  granted     Boolean
  grantedAt   DateTime
  revokedAt   DateTime?
  ipAddress   String?
  userAgent   String?

  @@map("gdpr_consent_logs")
}

// Seller Invitation model
model SellerInvitation {
  id         String           @id @default(uuid())
  email      String
  sellerType SellerType
  invitedBy  String
  user       User             @relation("InvitedBy", fields: [invitedBy], references: [id])
  token      String           @unique
  status     InvitationStatus @default(PENDING)
  expiresAt  DateTime
  acceptedAt DateTime?
  message    String?          @db.Text
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([email])
  @@index([token])
  @@index([status])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// Activity Log model
model ActivityLog {
  id          String   @id @default(uuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  sellerId    String?
  seller      Seller?  @relation(fields: [sellerId], references: [id])
  action      String // e.g., "PRODUCT_CREATED", "ORDER_FULFILLED"
  entityType  String // e.g., "Product", "Order"
  entityId    String?
  description String   @db.Text
  metadata    Json? // Before/after states, additional context
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([sellerId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([createdAt])
}

// Transaction model
model Transaction {
  id            String            @id @default(uuid())
  type          TransactionType
  amount        Decimal           @db.Decimal(10, 2)
  currency      String            @default("GBP")
  status        TransactionStatus @default(PENDING)
  sellerId      String?
  seller        Seller?           @relation(fields: [sellerId], references: [id])
  customerId    String?
  customer      User?             @relation("CustomerTransactions", fields: [customerId], references: [id])
  orderId       String?
  order         Order?            @relation(fields: [orderId], references: [id])
  settlementId  String?
  settlement    Settlement?       @relation(fields: [settlementId], references: [id])
  returnId      String?
  returnRequest ReturnRequest?    @relation(fields: [returnId], references: [id])
  description   String?           @db.Text
  metadata      Json?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@index([sellerId])
  @@index([customerId])
  @@index([orderId])
  @@index([settlementId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

enum TransactionType {
  PAYMENT
  PAYOUT
  REFUND
  FEE
  ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

// Discrepancy model
model Discrepancy {
  id            String              @id @default(uuid())
  type          DiscrepancyType
  sellerId      String?
  seller        Seller?             @relation(fields: [sellerId], references: [id])
  orderId       String?
  order         Order?              @relation(fields: [orderId], references: [id])
  productId     String?
  product       Product?            @relation(fields: [productId], references: [id])
  settlementId  String?
  settlement    Settlement?         @relation(fields: [settlementId], references: [id])
  severity      DiscrepancySeverity @default(MEDIUM)
  status        DiscrepancyStatus   @default(OPEN)
  expectedValue Json?
  actualValue   Json?
  description   String              @db.Text
  resolvedBy    String?
  resolvedAt    DateTime?
  resolution    String?             @db.Text
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([sellerId])
  @@index([type])
  @@index([severity])
  @@index([status])
  @@index([createdAt])
}

enum DiscrepancyType {
  INVENTORY
  PRICING
  SETTLEMENT
  ORDER_FULFILLMENT
}

enum DiscrepancySeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DiscrepancyStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  DISMISSED
}

// Support Ticket model
model SupportTicket {
  id                    String                 @id @default(uuid())
  ticketNumber          String                 @unique
  userId                String?
  user                  User?                  @relation("UserTickets", fields: [userId], references: [id])
  sellerId              String?
  seller                Seller?                @relation(fields: [sellerId], references: [id])
  orderId               String?
  order                 Order?                 @relation("OrderTickets", fields: [orderId], references: [id])
  subject               String
  category              TicketCategory
  priority              TicketPriority         @default(MEDIUM)
  status                TicketStatus           @default(OPEN)
  assignedTo            String?
  assignedAgent         User?                  @relation("AssignedTickets", fields: [assignedTo], references: [id])
  slaDueAt              DateTime?
  messages              TicketMessage[]
  whatsappConversations WhatsAppConversation[]
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  resolvedAt            DateTime?

  @@index([userId])
  @@index([sellerId])
  @@index([status])
  @@index([assignedTo])
  @@index([category])
  @@index([priority])
  @@index([createdAt])
}

model TicketMessage {
  id          String        @id @default(uuid())
  ticketId    String
  ticket      SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  userId      String?
  user        User?         @relation("TicketMessages", fields: [userId], references: [id])
  content     String        @db.Text
  isInternal  Boolean       @default(false)
  attachments Json?
  createdAt   DateTime      @default(now())

  @@index([ticketId])
  @@index([userId])
  @@index([createdAt])
}

enum TicketCategory {
  ORDER_INQUIRY
  PRODUCT_QUESTION
  RETURN_REQUEST
  PAYMENT_ISSUE
  TECHNICAL_SUPPORT
  SELLER_SUPPORT
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  ASSIGNED
  IN_PROGRESS
  WAITING_CUSTOMER
  RESOLVED
  CLOSED
}

// Knowledge Base Article model
model KnowledgeBaseArticle {
  id          String   @id @default(uuid())
  title       String
  slug        String   @unique
  content     String   @db.Text
  category    String
  tags        String[]
  isPublished Boolean  @default(false)
  views       Int      @default(0)
  helpful     Int      @default(0)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([isPublished])
  @@index([slug])
  @@index([createdAt])
}

// WhatsApp Conversation model
model WhatsAppConversation {
  id            String             @id @default(uuid())
  phoneNumber   String
  userId        String?
  user          User?              @relation(fields: [userId], references: [id])
  sellerId      String?
  seller        Seller?            @relation(fields: [sellerId], references: [id])
  ticketId      String?
  ticket        SupportTicket?     @relation(fields: [ticketId], references: [id])
  status        ConversationStatus @default(ACTIVE)
  lastMessageAt DateTime?
  messages      WhatsAppMessage[]
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([phoneNumber])
  @@index([userId])
  @@index([sellerId])
  @@index([ticketId])
  @@index([status])
}

model WhatsAppMessage {
  id             String               @id @default(uuid())
  conversationId String
  conversation   WhatsAppConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messageId      String               @unique
  direction      MessageDirection
  content        String               @db.Text
  mediaUrl       String?
  status         MessageStatus        @default(SENT)
  deliveredAt    DateTime?
  readAt         DateTime?
  metadata       Json?
  createdAt      DateTime             @default(now())

  @@index([conversationId])
  @@index([messageId])
  @@index([direction])
  @@index([status])
  @@index([createdAt])
}

model WhatsAppTemplate {
  id         String   @id @default(uuid())
  name       String   @unique
  category   String
  content    String   @db.Text
  variables  String[]
  isActive   Boolean  @default(true)
  approvedBy String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([category])
  @@index([isActive])
}

enum ConversationStatus {
  ACTIVE
  ARCHIVED
  BLOCKED
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

// Taxonomy System Models

// Category Model (3-level hierarchy)
model Category {
  id          String      @id @default(uuid())
  name        String
  slug        String      @unique
  parentId    String?
  parent      Category?   @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[]  @relation("CategoryHierarchy")
  level       Int // 0 = Fandom (top-level), 1 = category, 2 = sub-category
  path        String // Full path: "/clothing/t-shirts/graphic-tees"
  description String?     @db.Text
  image       String?
  order       Int         @default(0)
  isActive    Boolean     @default(true)
  products    Product[]
  attributes  Attribute[] // Category-specific attributes
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([parentId])
  @@index([level])
  @@index([slug])
  @@map("categories")
}

// Attribute Model
model Attribute {
  id                String             @id @default(uuid())
  name              String // e.g., "Size", "Color", "Material"
  slug              String             @unique
  type              AttributeType
  isRequired        Boolean            @default(false)
  isFilterable      Boolean            @default(true)
  isSearchable      Boolean            @default(false)
  isGlobal          Boolean            @default(false) // Global vs category-specific
  categoryId        String? // null = global, set = category-specific
  category          Category?          @relation(fields: [categoryId], references: [id])
  values            AttributeValue[]
  productAttributes ProductAttribute[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([categoryId])
  @@index([isGlobal])
  @@map("attributes")
}

enum AttributeType {
  TEXT
  NUMBER
  SELECT
  BOOLEAN
  DATE
}

// Attribute Value Model (for SELECT type attributes)
model AttributeValue {
  id                String             @id @default(uuid())
  attributeId       String
  attribute         Attribute          @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  value             String // e.g., "Small", "Red", "Cotton"
  slug              String
  order             Int                @default(0)
  productAttributes ProductAttribute[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@unique([attributeId, slug])
  @@index([attributeId])
  @@map("attribute_values")
}

// Product Attribute Junction
model ProductAttribute {
  id               String          @id @default(uuid())
  productId        String
  product          Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  attributeId      String
  attribute        Attribute       @relation(fields: [attributeId], references: [id])
  attributeValueId String?
  attributeValue   AttributeValue? @relation(fields: [attributeValueId], references: [id])
  textValue        String? // For TEXT type
  numberValue      Decimal?        @db.Decimal(10, 2) // For NUMBER type
  booleanValue     Boolean? // For BOOLEAN type
  dateValue        DateTime? // For DATE type
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  @@unique([productId, attributeId])
  @@index([productId])
  @@index([attributeId])
  @@map("product_attributes")
}

// Tag Model
model Tag {
  id          String       @id @default(uuid())
  name        String
  slug        String       @unique
  category    TagCategory
  description String?      @db.Text
  synonyms    String[] // Alternative names for search
  isActive    Boolean      @default(true)
  products    ProductTag[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([category])
  @@index([slug])
  @@map("tags")
}

enum TagCategory {
  THEME
  OCCASION
  STYLE
  CHARACTER
  FANDOM
  CUSTOM
}

// Product Tag Junction
model ProductTag {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  tagId     String
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([productId, tagId])
  @@index([productId])
  @@index([tagId])
  @@map("product_tags")
}

// Promotion model
model Promotion {
  id          String          @id @default(uuid())
  name        String
  description String?         @db.Text
  type        PromotionType
  status      PromotionStatus @default(ACTIVE)
  priority    Int             @default(0) // Higher priority = applied first
  startDate   DateTime
  endDate     DateTime?
  conditions  Json // Rule conditions (cart value, product attributes, customer group, etc.)
  actions     Json // Discount actions (percentage, fixed, free shipping, etc.)
  isStackable Boolean         @default(false)
  usageLimit  Int? // Total usage limit
  usageCount  Int             @default(0)
  userUsageLimit Int? // Per-customer usage limit (e.g. 1 = one use per customer)
  sellerId    String? // If null, platform-wide promotion
  seller      Seller?         @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  coupons     Coupon[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([status])
  @@index([startDate, endDate])
  @@index([sellerId])
  @@map("promotions")
}

enum PromotionType {
  PERCENTAGE_DISCOUNT
  FIXED_DISCOUNT
  BUY_X_GET_Y
  FREE_SHIPPING
  PRODUCT_DISCOUNT
  CART_DISCOUNT
}

enum PromotionStatus {
  DRAFT
  ACTIVE
  INACTIVE
  EXPIRED
}

// Coupon model
model Coupon {
  id          String        @id @default(uuid())
  code        String        @unique
  promotionId String
  promotion   Promotion     @relation(fields: [promotionId], references: [id], onDelete: Cascade)
  usageLimit  Int? // Per-coupon usage limit
  usageCount  Int           @default(0)
  userLimit   Int? // Per-user usage limit (default: 1)
  expiresAt   DateTime?
  status      CouponStatus  @default(ACTIVE)
  usedBy      CouponUsage[]
  carts       Cart[] // Carts using this coupon
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([code])
  @@index([promotionId])
  @@index([status])
  @@map("coupons")
}

enum CouponStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  EXHAUSTED
}

// Coupon Usage tracking
model CouponUsage {
  id             String   @id @default(uuid())
  couponId       String
  coupon         Coupon   @relation(fields: [couponId], references: [id], onDelete: Cascade)
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderId        String?
  order          Order?   @relation(fields: [orderId], references: [id], onDelete: SetNull)
  discountAmount Decimal  @db.Decimal(10, 2)
  createdAt      DateTime @default(now())

  @@unique([couponId, userId, orderId])
  @@index([couponId])
  @@index([userId])
  @@index([orderId])
  @@map("coupon_usages")
}

// Customer Group model
model CustomerGroup {
  id          String            @id @default(uuid())
  name        String            @unique
  description String?           @db.Text
  type        CustomerGroupType @default(REGULAR)
  isActive    Boolean           @default(true)
  customers   User[] // Users in this group
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@map("customer_groups")
}

enum CustomerGroupType {
  REGULAR
  VIP
  WHOLESALE
  CORPORATE
  STUDENT
  SENIOR
}

// Shipping Method model
model ShippingMethod {
  id          String             @id @default(uuid())
  name        String
  description String?            @db.Text
  type        ShippingMethodType
  isActive    Boolean            @default(true)
  sellerId    String? // If null, platform-wide
  seller      Seller?            @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  rules       ShippingRule[]
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([sellerId])
  @@index([isActive])
  @@map("shipping_methods")
}

enum ShippingMethodType {
  FLAT_RATE
  WEIGHT_BASED
  DISTANCE_BASED
  FREE_SHIPPING
  PICKUP_IN_STORE
  HYPERLOCAL
}

// Shipping Rule model
model ShippingRule {
  id                    String         @id @default(uuid())
  shippingMethodId      String
  shippingMethod        ShippingMethod @relation(fields: [shippingMethodId], references: [id], onDelete: Cascade)
  name                  String
  priority              Int            @default(0)
  conditions            Json // Conditions (weight range, cart value, country, etc.)
  rate                  Decimal        @db.Decimal(10, 2)
  freeShippingThreshold Decimal?       @db.Decimal(10, 2) // Free shipping if cart value >= this
  estimatedDays         Int? // Estimated delivery days
  isActive              Boolean        @default(true)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@index([shippingMethodId])
  @@index([isActive])
  @@map("shipping_rules")
}

// Warehouse model
model Warehouse {
  id            String              @id @default(uuid())
  name          String
  code          String              @unique // Warehouse code (e.g., "WH-LON-01")
  address       String
  city          String
  state         String?
  country       String
  postalCode    String
  latitude      Float?
  longitude     Float?
  contactEmail  String?
  contactPhone  String?
  managerName   String?
  capacity      Int? // Storage capacity in cubic meters or units
  warehouseType String?             @default("DISTRIBUTION") // DISTRIBUTION, RETURNS, COLD_STORAGE, etc.
  isActive      Boolean             @default(true)
  inventory     InventoryLocation[]
  transfersFrom StockTransfer[]     @relation("FromWarehouse")
  transfersTo   StockTransfer[]     @relation("ToWarehouse")
  orders        Order[]
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([code])
  @@index([isActive])
  @@index([city])
  @@index([country])
  @@map("warehouses")
}

// Inventory Location model (stock per warehouse)
model InventoryLocation {
  id                String             @id @default(uuid())
  warehouseId       String
  warehouse         Warehouse          @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  productId         String
  product           Product            @relation(fields: [productId], references: [id], onDelete: Cascade)
  quantity          Int                @default(0)
  reserved          Int                @default(0) // Reserved for pending orders
  lowStockThreshold Int                @default(10)
  stockReservations StockReservation[]
  stockMovements    StockMovement[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@unique([warehouseId, productId])
  @@index([warehouseId])
  @@index([productId])
  @@index([quantity])
  @@map("inventory_locations")
}

// Stock Reservation model
model StockReservation {
  id                  String            @id @default(uuid())
  inventoryLocationId String
  inventoryLocation   InventoryLocation @relation(fields: [inventoryLocationId], references: [id], onDelete: Cascade)
  orderId             String?
  order               Order?            @relation(fields: [orderId], references: [id], onDelete: SetNull)
  cartId              String? // For cart reservations
  quantity            Int
  expiresAt           DateTime // Reservation expiry
  status              ReservationStatus @default(ACTIVE)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@index([inventoryLocationId])
  @@index([orderId])
  @@index([cartId])
  @@index([status])
  @@index([expiresAt])
  @@map("stock_reservations")
}

enum ReservationStatus {
  ACTIVE
  CONFIRMED
  EXPIRED
  CANCELLED
}

// Stock Transfer model
model StockTransfer {
  id              String         @id @default(uuid())
  fromWarehouseId String
  fromWarehouse   Warehouse      @relation("FromWarehouse", fields: [fromWarehouseId], references: [id], onDelete: Cascade)
  toWarehouseId   String
  toWarehouse     Warehouse      @relation("ToWarehouse", fields: [toWarehouseId], references: [id], onDelete: Cascade)
  productId       String
  product         Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  quantity        Int
  status          TransferStatus @default(PENDING)
  requestedBy     String // User ID who requested the transfer
  completedBy     String? // User ID who completed the transfer
  notes           String?        @db.Text
  completedAt     DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([fromWarehouseId])
  @@index([toWarehouseId])
  @@index([productId])
  @@index([status])
  @@index([requestedBy])
  @@map("stock_transfers")
}

enum TransferStatus {
  PENDING
  IN_TRANSIT
  COMPLETED
  CANCELLED
  REJECTED
}

// Stock Movement model (audit trail for all stock changes)
model StockMovement {
  id                  String            @id @default(uuid())
  inventoryLocationId String
  inventoryLocation   InventoryLocation @relation(fields: [inventoryLocationId], references: [id], onDelete: Cascade)
  productId           String
  product             Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  quantity            Int // Positive for additions, negative for deductions
  movementType        MovementType
  referenceType       String? // 'ORDER', 'TRANSFER', 'ADJUSTMENT', 'RETURN', 'RESERVATION'
  referenceId         String? // ID of the related entity (orderId, transferId, etc.)
  performedBy         String? // User ID who performed the action
  notes               String?           @db.Text
  createdAt           DateTime          @default(now())

  @@index([inventoryLocationId])
  @@index([productId])
  @@index([movementType])
  @@index([referenceType, referenceId])
  @@index([createdAt])
  @@map("stock_movements")
}

enum MovementType {
  IN // Stock in (receiving, transfer in, return)
  OUT // Stock out (order fulfillment, transfer out)
  ADJUST // Manual adjustment (correction, damage, etc.)
  RESERVE // Reservation (doesn't change quantity, tracked separately)
  RELEASE // Release reservation
}

// Tax Zone model
model TaxZone {
  id          String    @id @default(uuid())
  name        String
  country     String?
  state       String?
  city        String?
  postalCodes String[] // Array of postal code ranges
  isActive    Boolean   @default(true)
  rates       TaxRate[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([country])
  @@index([isActive])
  @@map("tax_zones")
}

// Tax Class model
model TaxClass {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?   @db.Text
  rates       TaxRate[]
  products    Product[] // Products using this tax class
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("tax_classes")
}

// Tax Rate model
model TaxRate {
  id          String    @id @default(uuid())
  taxZoneId   String
  taxZone     TaxZone   @relation(fields: [taxZoneId], references: [id], onDelete: Cascade)
  taxClassId  String?
  taxClass    TaxClass? @relation(fields: [taxClassId], references: [id], onDelete: SetNull)
  rate        Decimal   @db.Decimal(5, 4) // e.g., 0.20 for 20%
  isInclusive Boolean   @default(false) // Tax-inclusive pricing
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([taxZoneId, taxClassId])
  @@index([taxZoneId])
  @@index([taxClassId])
  @@index([isActive])
  @@map("tax_rates")
}

// Webhook model
model Webhook {
  id         String            @id @default(uuid())
  url        String
  events     String[] // Array of event types to subscribe to
  secret     String? // Webhook secret for signature verification
  isActive   Boolean           @default(true)
  sellerId   String? // If null, platform-wide webhook
  seller     Seller?           @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt

  @@index([sellerId])
  @@index([isActive])
  @@map("webhooks")
}

// Webhook Delivery model (tracking webhook deliveries)
model WebhookDelivery {
  id          String         @id @default(uuid())
  webhookId   String
  webhook     Webhook        @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  event       String
  payload     Json
  status      DeliveryStatus @default(PENDING)
  statusCode  Int?
  response    String?        @db.Text
  attempts    Int            @default(0)
  deliveredAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([webhookId])
  @@index([status])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

enum DeliveryStatus {
  PENDING
  SUCCESS
  FAILED
  RETRYING
}

// Integration Configuration model - Stores third-party API credentials and settings
model IntegrationConfig {
  id            String    @id @default(uuid())
  category      String // PAYMENT, SHIPPING, TAX, EMAIL, STORAGE, ANALYTICS, etc.
  provider      String // stripe, fedex, avalara, sendgrid, etc.
  displayName   String // User-friendly name
  description   String?   @db.Text
  isActive      Boolean   @default(false)
  isTestMode    Boolean   @default(true)
  credentials   String    @db.Text // Encrypted JSON containing API keys/secrets
  settings      Json? // Provider-specific non-sensitive settings
  webhookUrl    String? // Generated webhook URL for this integration
  webhookSecret String? // For webhook signature verification
  lastTestedAt  DateTime?
  testStatus    String? // SUCCESS, FAILED, NEVER_TESTED
  testMessage   String?   @db.Text // Error message or success details
  priority      Int       @default(0) // For ordering when multiple providers in same category
  metadata      Json? // Additional provider-specific metadata
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  logs IntegrationLog[]

  @@unique([category, provider])
  @@index([category])
  @@index([isActive])
  @@index([provider])
  @@map("integration_configs")
}

// Integration Log model - Tracks API calls and events for integrations
model IntegrationLog {
  id              String            @id @default(uuid())
  integrationId   String
  integration     IntegrationConfig @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  action          String // API_CALL, WEBHOOK_RECEIVED, TEST_CONNECTION, ERROR, CONFIG_CHANGE
  provider        String // Denormalized for easier querying
  endpoint        String? // API endpoint called
  method          String? // HTTP method (GET, POST, PUT, DELETE)
  statusCode      Int? // HTTP response status code
  duration        Int? // Request duration in milliseconds
  requestSummary  String?           @db.Text // Truncated/sanitized request (no secrets)
  responseSummary String?           @db.Text // Truncated/sanitized response
  errorMessage    String?           @db.Text // Error details if failed
  metadata        Json? // Additional context data
  ipAddress       String? // IP address of the caller (for config changes)
  userId          String? // User who triggered the action
  createdAt       DateTime          @default(now())

  @@index([integrationId])
  @@index([createdAt])
  @@index([provider])
  @@index([action])
  @@map("integration_logs")
}

// Integration Category enum reference (stored as String for flexibility)
// Categories: PAYMENT, SHIPPING, TAX, EMAIL, SMS, STORAGE, SEARCH, ANALYTICS, MAPS, OAUTH

// ============================================
// INFLUENCER MODULE MODELS
// ============================================

// Influencer Invitation (invitation-only onboarding)
model InfluencerInvitation {
  id                 String           @id @default(uuid())
  email              String
  invitedBy          String
  user               User             @relation("InfluencerInvitedBy", fields: [invitedBy], references: [id])
  token              String           @unique
  status             InvitationStatus @default(PENDING)
  expiresAt          DateTime
  acceptedAt         DateTime?
  message            String?          @db.Text
  baseCommissionRate Decimal?         @db.Decimal(5, 4) // Pre-configured commission
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  @@index([email])
  @@index([token])
  @@index([status])
  @@map("influencer_invitations")
}

// Influencer Profile
model Influencer {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Profile
  displayName  String
  slug         String  @unique
  bio          String? @db.Text
  profileImage String?
  bannerImage  String?
  socialLinks  Json? // { instagram, youtube, tiktok, twitter, website }

  // Referral
  referralCode   String @unique
  cookieDuration Int    @default(30) // Days

  // Flexible Commission Configuration
  baseCommissionRate  Decimal @default(0.10) @db.Decimal(5, 4)
  categoryCommissions Json? // { "categoryId": 0.15, "categoryId2": 0.12 }

  // Status
  status InfluencerStatus @default(ACTIVE)
  tier   InfluencerTier   @default(BRONZE)

  // Stats (denormalized for performance)
  totalClicks      Int     @default(0)
  totalConversions Int     @default(0)
  totalSalesAmount Decimal @default(0) @db.Decimal(10, 2)
  totalCommission  Decimal @default(0) @db.Decimal(10, 2)

  // Relations
  storefront   InfluencerStorefront?
  referrals    Referral[]
  commissions  InfluencerCommission[]
  payouts      InfluencerPayout[]
  campaigns    InfluencerCampaign[]
  productLinks InfluencerProductLink[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([referralCode])
  @@index([status])
  @@map("influencers")
}

enum InfluencerStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
}

enum InfluencerTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

// Influencer Storefront (Full Custom)
model InfluencerStorefront {
  id           String     @id @default(uuid())
  influencerId String     @unique
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  // Theme Customization
  primaryColor    String @default("#7C3AED")
  secondaryColor  String @default("#F3E8FF")
  backgroundColor String @default("#FFFFFF")
  textColor       String @default("#1F2937")
  fontFamily      String @default("Inter")

  // Layout
  layoutType      String  @default("grid") // grid, list, masonry
  showBanner      Boolean @default(true)
  showBio         Boolean @default(true)
  showSocialLinks Boolean @default(true)

  // Content Blocks (flexible sections)
  contentBlocks Json? // Array of { type, order, data }
  // Types: hero, featured_products, text, image, video, testimonial, cta

  // Featured Products
  featuredProductIds String[] @default([])

  // Custom Domain (future)
  customDomain String? @unique

  // SEO
  metaTitle       String?
  metaDescription String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("influencer_storefronts")
}

// Influencer Product Link
model InfluencerProductLink {
  id           String     @id @default(uuid())
  influencerId String
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  productId    String
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Custom URL slug (optional)
  customSlug String?

  // Stats
  clicks      Int @default(0)
  conversions Int @default(0)

  createdAt DateTime @default(now())

  @@unique([influencerId, productId])
  @@index([influencerId])
  @@map("influencer_product_links")
}

// Influencer Campaign (with override rates)
model InfluencerCampaign {
  id           String     @id @default(uuid())
  influencerId String
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  name        String
  description String?  @db.Text
  startDate   DateTime
  endDate     DateTime

  // Commission Override (takes priority over base/category rates)
  overrideCommissionRate Decimal? @db.Decimal(5, 4)

  // Specific products (optional - if empty, applies to all)
  productIds  String[] @default([])
  categoryIds String[] @default([])

  // Tracking
  totalClicks      Int     @default(0)
  totalConversions Int     @default(0)
  totalSales       Decimal @default(0) @db.Decimal(10, 2)

  status CampaignStatus @default(ACTIVE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([influencerId])
  @@index([status])
  @@map("influencer_campaigns")
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
}

// Referral Tracking
model Referral {
  id           String     @id @default(uuid())
  influencerId String
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  // Visitor tracking
  visitorId String? // Browser fingerprint/cookie ID
  userId    String? // If visitor registers

  // Attribution
  landingPage String?
  productId   String? // If landed on specific product
  campaignId  String? // If from specific campaign
  utmParams   Json? // { source, medium, campaign, content }

  // Conversion
  orderId     String?   @unique
  order       Order?    @relation(fields: [orderId], references: [id])
  convertedAt DateTime?
  orderTotal  Decimal?  @db.Decimal(10, 2)

  expiresAt DateTime
  createdAt DateTime @default(now())

  // Commission relation
  commission InfluencerCommission?

  @@index([influencerId])
  @@index([visitorId])
  @@map("referrals")
}

// Influencer Commission
model InfluencerCommission {
  id           String     @id @default(uuid())
  influencerId String
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  referralId   String     @unique
  referral     Referral   @relation(fields: [referralId], references: [id], onDelete: Cascade)
  orderId      String

  // Order Details
  orderTotal Decimal @db.Decimal(10, 2)
  currency   String  @default("GBP")

  // Commission Calculation (stored at time of conversion)
  rateSource  String // BASE, CATEGORY, CAMPAIGN
  rateApplied Decimal @db.Decimal(5, 4)
  amount      Decimal @db.Decimal(10, 2)

  // Status
  status CommissionStatus @default(PENDING)

  // Payout reference (when paid)
  payoutId String?
  payout   InfluencerPayout? @relation(fields: [payoutId], references: [id])

  // Notes (for manual adjustments)
  notes String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([influencerId])
  @@index([status])
  @@map("influencer_commissions")
}

enum CommissionStatus {
  PENDING // Order placed
  APPROVED // Order delivered
  PAID // Manually marked as paid
  CANCELLED // Order cancelled/returned
  ADJUSTED // Manually adjusted
}

// Influencer Payout (Manual Tracking)
model InfluencerPayout {
  id           String     @id @default(uuid())
  influencerId String
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  // Period
  periodStart DateTime
  periodEnd   DateTime

  // Amount
  totalAmount Decimal @db.Decimal(10, 2)
  currency    String  @default("GBP")

  // Manual Payment Details
  paymentMethod String? // BANK, PAYPAL, etc.
  paymentRef    String? // External reference number
  paidAt        DateTime?
  paidBy        String? // Admin user ID who processed

  status PayoutStatus @default(PENDING)
  notes  String?      @db.Text

  commissions InfluencerCommission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([influencerId])
  @@index([status])
  @@map("influencer_payouts")
}

enum PayoutStatus {
  PENDING
  PAID
  CANCELLED
}

// Newsletter subscriptions (all user roles can subscribe; admin/marketing/cms manage)
model NewsletterSubscription {
  id             String    @id @default(uuid())
  email          String    @unique
  userId         String?
  user           User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  status         String    @default("subscribed") // subscribed, unsubscribed
  source         String?   @default("website")   // website, checkout, api
  tags           Json?     // segmentation e.g. { role: "customer", fandom: "hp" }
  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([email])
  @@index([status])
  @@index([userId])
  @@map("newsletter_subscriptions")
}
